# -*- coding: utf-8 -*-
"""
/***************************************************************************
 RouteNetworkDialog
                                 A QGIS plugin
 Route Network for MTDI
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2024-03-28
        git sha              : $Format:%H$
        copyright            : (C) 2024 by Doronin Ivan
        email                : ivandoronin22@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
import asyncio
import pandas as pd
import time
import json
from qgis.PyQt import uic
from qgis.PyQt import QtWidgets
from qgis.core import *
from qgis.gui import QgsMapCanvas
from qgis.PyQt.QtGui import *
from PyQt5.QtCore import *
from PyQt5.QtWidgets import *
from shapely.geometry import box
import processing
from .asyncNetworkVariants import AsyncNetworkVariants

# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'route_network_dialog_base.ui'))


class RouteNetworkDialog(QtWidgets.QDialog, FORM_CLASS):


    def __init__(self, parent=None):
        """Constructor."""
        super(RouteNetworkDialog, self).__init__(parent)
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)

        # Variables.
        self.path = ''
        self.date = ''
        self.reg = ''
        self.flag = False
        self.df = None
        
        # Check boxes.
        self.company_box.addItem("Выберите перевозчика...", None)
        self.company_box.addItem("МТА", 1)
        self.company_box.addItem("КП", 2)

        self.time_box.addItem("Выберите время...", None)
        self.time_box.addItem("весь день", 1)
        self.time_box.addItem("час пик", 2)
        self.time_box.addItem("вечерчние часы пик", 3)

        self.check_box.stateChanged.connect(self.handleCheckBoxStateChanged)

        # Buttons.
        self.button_prc.clicked.connect(self.button_percentage_clicked)
        self.button_dwnl.clicked.connect(self.button_download_clicked)
        self.browse_button.clicked.connect(self.show_file_dialog)
        self.button_prc_group.clicked.connect(self.button_percentage_group_clicked)
        self.button_find.clicked.connect(self.button_find_clicked)
        self.button_layer.clicked.connect(self.button_layer_clicked)
        self.save_button.clicked.connect(self.save_button_clicked)
        self.save_button.setVisible(False)
        self.expand_button.clicked.connect(self.expand_button_clicked)
        self.stop_point_button.clicked.connect(self.stop_point_button_clicked)
        self.intersection_button.clicked.connect(self.button_intersection_clicked)
        self.jk_layer_button.clicked.connect(self.jk_layer_button_clicked)
        self.jd_layer_button.clicked.connect(self.jd_layer_button_clicked)
        self.population_layer_button.clicked.connect(self.population_layer_button_clicked)

        # Date.
        self.date_edit.setDate(QDate.currentDate())

        # Table Widgets.
        self.table_widget.cellClicked.connect(self.cell_clicked)


    def get_visible_layers(self, node):
        layers = []
        for child_node in node.children():
            if isinstance(child_node, QgsProject) or child_node.isVisible():
                if isinstance(child_node, QgsProject):
                    # Recursively get layers from child groups
                    layers.extend(get_visible_layers(child_node))
                elif isinstance(child_node, QgsLayerTreeGroup):
                    # Recursively get layers from child groups
                    layers.extend(self.get_visible_layers(child_node))
                else:
                    # For QgsLayerTreeLayer objects, add the layer to the list
                    layers.append(child_node.layer())
        return layers


    def get_active_layers(self):
        # Получить список всех активно выбранных слоев в Layers Panel
        selected_layers = self.get_visible_layers(QgsProject.instance().layerTreeRoot())
        layer_coordinates_by_peregons = []
        for layer in selected_layers:
            if isinstance(layer, QgsVectorLayer):
                if layer.featureCount() > 0:
                    coordinates = self.get_coordinates_by_peregons(layer)
                    if len(coordinates) != 0:
                        if 'reverse' in layer.name():
                            coordinates = list(reversed(coordinates))

                        layer_coordinates_by_peregons.append({
                            'name': layer.name(),
                            'coordinates': coordinates
                        })

        return layer_coordinates_by_peregons


    def get_coordinates_by_peregons(self, layer):
        coordinates_list = []
        start_peregon = None
        end_peregon = None
        for feature in layer.getFeatures():
            geometry_type = feature.geometry().wkbType()
            if geometry_type == QgsWkbTypes.Point:
                point = feature.geometry().asPoint()
                if start_peregon is not None:
                    end_peregon = (point.x(), point.y())
                    coordinates_list.append({'start_peregon': start_peregon, 'end_peregon': end_peregon})
                    start_peregon = end_peregon
                if start_peregon is None:
                    start_peregon = (point.x(), point.y())

        return coordinates_list
  
  
    def get_active_layers_in_group(self, group):
        active_layers = []
        for layer_tree_node in group.children():
            if isinstance(layer_tree_node, QgsLayerTreeLayer) and layer_tree_node.isVisible():
                layer = layer_tree_node.layer()
                if isinstance(layer, QgsVectorLayer):
                    if layer.featureCount() > 0:
                        coordinates = self.get_coordinates_by_peregons(layer)
                        if len(coordinates) != 0:
                            if 'reverse' in layer.name():
                                coordinates = list(reversed(coordinates))

                            active_layers.append({
                                'name': layer.name(),
                                'coordinates': coordinates
                            })
        return active_layers

        
    def get_visible_group_layers(self):
        root = QgsProject.instance().layerTreeRoot()
        group_layers_dict = []
        for child in root.children():
            if isinstance(child, QgsLayerTreeGroup):
                active_layers = self.get_active_layers_in_group(child)
                if len(active_layers) != 0:
                    group_layers_dict.append({'group_name': child.name(), 'layers': active_layers})
        if len(group_layers_dict) != 2:
            return None
        
        return group_layers_dict
    
    
    def find_coordinate_peregon(self, peregons_coordinates, second_layer):
        distance_area = QgsDistanceArea()
        distance_area.setEllipsoid('WGS84')
        flag = False
        for peregon in second_layer:
            if flag == False:
                point_start_1 = QgsPointXY(peregons_coordinates['start_peregon'][1], peregons_coordinates['start_peregon'][0])
                point_start_2 = QgsPointXY(peregon['start_peregon'][1], peregon['start_peregon'][0])
                distance_x = distance_area.measureLine([point_start_1, point_start_2])
                
            point_end_1 = QgsPointXY(peregons_coordinates['end_peregon'][1], peregons_coordinates['end_peregon'][0])
            point_end_2 = QgsPointXY(peregon['end_peregon'][1], peregon['end_peregon'][0])
            distance_y = distance_area.measureLine([point_end_1, point_end_2])
            if (distance_x <= 200) and (distance_y <= 200):
                return 1
            elif (distance_x <= 200) and (distance_y > 200):
                flag = True
        return 0


    def add_peregons_to_project(self, matching_peregons):
        line_layer = QgsVectorLayer('LineString?crs=epsg:4326', "MathPeregons", 'memory')
        provider = line_layer.dataProvider()

        fields = QgsFields()
        fields.append(QgsField('ID', QVariant.Int))

        line_layer.startEditing()

        line_geometry = QgsGeometry.fromPolylineXY(mathcing_peregons)

        feature = QgsFeature()
        feature.setGeometry(line_geometry)
        feature.setAttributes([1])

        provider.addFeature(feature)

        line_layer.commitChanges()
        QgsProject.instance().addMapLayer(line_layer)


    def show_table(self, height, width, layer_coordinates_by_peregons):
        column_headers = []
        row_headers = []
        values = []
        self.progress.setMaximum(len(layer_coordinates_by_peregons))
        index = 0
        self.status_label.setText('Расчет вариантов...')
        for item in layer_coordinates_by_peregons:
            index += 1
            name_1 = item['name']
            rows = []
            for item2 in layer_coordinates_by_peregons:
                matching_coordinates = 0
                for coordinate in item['coordinates']:
                    matching_coordinates += self.find_coordinate_peregon(coordinate, item2['coordinates'])
                peregons = f"{matching_coordinates}/{len(item['coordinates'])}"
                percent = (matching_coordinates / len(item['coordinates'])) * 100

                name_2 = item2['name']
                rows.append(f'совпадает на {round(percent, 2)} % ({peregons} перегонов)')
                if len(column_headers) < width:
                    column_headers.append(name_2)
            values.append(rows)
            if len(row_headers) < height:
                row_headers.append(name_1)
            time.sleep(0.1)
            self.progress.setValue(index)
            QApplication.processEvents()

        self.table_widget.setRowCount(height)
        self.table_widget.setColumnCount(width)
        self.table_widget.setHorizontalHeaderLabels(column_headers)
        self.table_widget.setVerticalHeaderLabels(row_headers)
        
        for row in range(len(values)):
            for col in range(len(values[0])):
                self.table_widget.setColumnWidth(col, 200)
                item = QTableWidgetItem(values[row][col])
                percent = float(values[row][col].split(' ')[2])
                if percent >= 50.0 and percent < 70.0 and row != col:
                    item.setBackground(QColor(200, 255, 200))
                if percent >= 70.0 and percent < 80.0 and row != col:
                    item.setBackground(QColor(255, 255, 200))
                if percent >= 80.0 and row != col:
                    item.setBackground(QColor(255, 200, 200))
                if row == col:
                    item = QTableWidgetItem()
                    item.setBackground(QColor(240, 240, 240))
                if percent == 0.0:
                    item = QTableWidgetItem()
                self.table_widget.setItem(row, col, item)
        self.status_label.setText('Готов к работе')

        dataset = {
            'Вариант_1': [],
            'Вариант_2': [],
            'Дублированность': [],
            'Совпадение_перегонов': []
            }

        for row in range(self.table_widget.rowCount()):
            row_data = []
            row_data.append(row_headers[row])
            for column in range(self.table_widget.columnCount()):
                item = self.table_widget.item(row, column)
                if item is not None:
                    row_data.append(item.text())
                    if item.text() != '':
                        row_text = self.table_widget.horizontalHeaderItem(row).text()
                        column_text = self.table_widget.verticalHeaderItem(column).text()
                        dubl = item.text().split(' ')[2] + ' %'
                        count_peregons = item.text().split(' ')[4].replace('(', '').replace(')', '').split(' ')[0]

                        dataset['Вариант_1'].append(row_text)
                        dataset['Вариант_2'].append(column_text)
                        dataset['Дублированность'].append(dubl)
                        dataset['Совпадение_перегонов'].append(count_peregons)
                else:
                    row_data.append('')
        col_data = ['#']
        col_data.extend(column_headers)
        df = pd.DataFrame(
            dataset
        )
        return df


    def show_table_for_group(self, width, height, group_layers):
        group_1 = group_layers[0]
        group_2 = group_layers[1]
        column_headers = []
        row_headers = []
        values = []
        self.progress.setMaximum(len(group_layers))
        index = 0
        self.status_label.setText('Расчет вариантов...')
        for layer in group_1['layers']:
            layer_name_1 = layer['name']
            layer_coordinates_1 = layer['coordinates']
            rows = []
            for layer_2 in group_2['layers']:
                layer_name_2 = layer_2['name']
                matching_coordinates = 0
                for coordinate in layer_coordinates_1:
                    matching_coordinates += self.find_coordinate_peregon(coordinate, layer_2['coordinates'])
                peregons = f"{matching_coordinates} / {len(layer_coordinates_1)}"
                percent = (matching_coordinates / len(layer_coordinates_1)) * 100
                rows.append(f'совпадает на {round(percent, 2)} % ({peregons} перегонов)')
                if len(column_headers) < width:
                    column_headers.append(layer_name_2)
                    
            values.append(rows)
            if len(row_headers) < height:
                row_headers.append(layer_name_1)
                
            time.sleep(0.1)
            self.progress.setValue(index)
            QApplication.processEvents()

        self.table_widget.setRowCount(height)
        self.table_widget.setColumnCount(width)
        self.table_widget.setHorizontalHeaderLabels(column_headers)
        self.table_widget.setVerticalHeaderLabels(row_headers)

        for row in range(len(values)):
            for col in range(len(values[0])):
                self.table_widget.setColumnWidth(col, 200)
                item = QTableWidgetItem(values[row][col])
                percent = float(values[row][col].split(' ')[2])
                if percent >= 50.0 and percent < 70.0 and row != col:
                    item.setBackground(QColor(200, 255, 200))
                if percent >= 70.0 and percent < 80.0 and row != col:
                    item.setBackground(QColor(255, 255, 200))
                if percent >= 80.0 and row != col:
                    item.setBackground(QColor(255, 200, 200))
                if percent == 0.0:
                    item = QTableWidgetItem()
                self.table_widget.setItem(row, col, item)
        self.status_label.setText('Готов к работе')

        dataset = {
            'Вариант_1': [],
            'Вариант_2': [],
            'Дублированность': [],
            'Совпадение_перегонов': []
            }

        for row in range(self.table_widget.rowCount()):
            row_data = []
            row_data.append(row_headers[row])
            for column in range(self.table_widget.columnCount()):
                item = self.table_widget.item(row, column)
                if item is not None:
                    row_data.append(item.text())
                    if item.text() != '':
                        row_text = self.table_widget.horizontalHeaderItem(row).text()
                        column_text = self.table_widget.verticalHeaderItem(column).text()
                        dubl = item.text().split(' ')[2] + ' %'
                        count_peregons = item.text().split(' ')[4].replace('(', '').replace(')', '').split(' ')[0]

                        dataset['Вариант_1'].append(row_text)
                        dataset['Вариант_2'].append(column_text)
                        dataset['Дублированность'].append(dubl)
                        dataset['Совпадение_перегонов'].append(count_peregons)
                else:
                    row_data.append('')
            
        col_data = ['#']
        col_data.extend(column_headers)

        df = pd.DataFrame(
            dataset
        )
        return df
    

    def set_layer_visibility(self, layer, visibility):
        root = QgsProject.instance().layerTreeRoot()

        # Iterate through layer tree to find the layer
        for child in root.children():
            if isinstance(child, QgsLayerTreeGroup):
                # Check if the child is a group
                for group_child in child.children():
                    if group_child.layer() == layer:
                        group_child.setItemVisibilityChecked(visibility)
                        break
            elif child.layer() == layer:
                child.setItemVisibilityChecked(visibility)
                break


    def set_active_layers(self, target_layers):
        layers = QgsProject.instance().mapLayers().values()

        for layer in layers:
            is_target_layer = any(keyword in layer.name() for keyword in target_layers)
            if layer.name() != '2gis Map' and layer.name() != 'OSM Standard' :
                self.set_layer_visibility(layer, is_target_layer)
    

    def button_percentage_clicked(self):
        self.status_label.setText('Подготавливаем варианты')
        active_coordinates = self.get_active_layers()
        height = len(active_coordinates)
        width = len(active_coordinates)
        self.df = self.show_table(height, width, active_coordinates)
        self.save_button.setVisible(True)
        

    def button_percentage_group_clicked(self):
        self.status_label.setText('Подготавливаем варианты')
        goup_layer_coordinates = self.get_visible_group_layers()
        if goup_layer_coordinates is not None:
            height = len(goup_layer_coordinates[0]['layers'])
            width = len(goup_layer_coordinates[1]['layers'])
            self.df = self.show_table_for_group(width, height, goup_layer_coordinates)
            self.save_button.setVisible(True)
        else:
            self.status_label.setText('<span style="color: rgb(250, 55, 55);">Выберите две группы слоев!</span>')
            return


    def button_find_clicked(self):
        reg = str(self.reg_edit.text())
        if reg != "":
            filtered_layers = [layer for layer in QgsProject.instance().mapLayers().values()
                    if reg == layer.name().split('-')[len(layer.name().split('-')) - 2]]

            self.set_active_layers([layer.name() for layer in filtered_layers])
            self.reg_edit.setText('')
        else:
            self.status_label.setText('<span style="color: rgb(250, 55, 55);">Поле не может быть пустым!</span>')
        return
  

    def button_download_clicked(self):
        selected_item = self.time_box.currentText()
        company = self.company_box.currentText()
    
        if selected_item == 'час пик':
            time = '05-10'
        elif selected_item == 'вечерчние часы пик':
            time = '17-21'
        else:
            time = '03-24'
            
        selected_date = self.date_edit.dateTime().date()
        self.date = selected_date.toString("yyyy-MM-dd")
        
        if company is None:
            self.status_label.setText('<span style="color: rgb(250, 55, 55);">Выберите перевозчика!</span>')
            return

        if self.path == '':
            self.status_label.setText('<span style="color: rgb(250, 55, 55);">Не введен путь к маршрутам!</span>')
            return

        if selected_item is None:
            self.status_label.setText('<span style="color: rgb(250, 55, 55);">Выберите время!</span>')
            return

        self.status_label.setText('Получаем варианты из РНИС...')
        self.network = AsyncNetworkVariants(self, self.path, self.date, time, company, self.flag)
        asyncio.run(self.network.progress_bar())
        self.progress.setValue(100)
        

    def button_layer_clicked(self):
        selected_item = self.time_box.currentText()
        company = self.company_box.currentText()
    
        if selected_item == 'час пик':
            time = '05-10'
        elif selected_item == 'вечерчние часы пик':
            time = '17-21'
        else:
            time = '03-24'
            
        selected_date = self.date_edit.dateTime().date()
        self.date = selected_date.toString("yyyy-MM-dd")
        
        if company is None:
            self.status_label.setText('<span style="color: rgb(250, 55, 55);">Выберите перевозчика!</span>')
            return

        if self.path == '':
            self.status_label.setText('<span style="color: rgb(250, 55, 55);">Не введен путь к маршрутам!</span>')
            return
            
        self.status_label.setText('Получаем варианты из РНИС...')
        self.network = AsyncNetworkVariants(self, self.path, self.date, time, company, self.flag)
        asyncio.run(self.network.progress_bar(type=2))
        self.progress.setValue(100)


    def cell_clicked(self, row, column):
        filtered_layers = []
        for layer in QgsProject.instance().mapLayers().values():
            if (layer.name() == self.table_widget.verticalHeaderItem(row).text()) or (layer.name() == self.table_widget.horizontalHeaderItem(column).text()) or (layer.name() == '2gis Map'):
                if layer.name() not in filtered_layers:
                    filtered_layers.append(layer.name())

        self.set_active_layers(filtered_layers)


    def show_file_dialog(self):
        file_dialog = QFileDialog()
        file_path, _ = file_dialog.getOpenFileName(self, 'Выберите файл')

        if file_path:
            self.path_edit.setText(file_path)
            self.path = file_path


    def handleCheckBoxStateChanged(self, state):
        if state == Qt.Checked:
            self.flag = True
        else:
            self.flag = False


    def save_button_clicked(self):
        if self.df is not None:
            options = QFileDialog.Options()
            options |= QFileDialog.DontUseNativeDialog
            file_name, _ = QFileDialog.getSaveFileName(self, "Выберите директорию", "", "Excel Files (*.xlsx);;All Files (*)", options=options)
            
            if file_name:
                self.df.to_excel(file_name + '.xlsx', index=False)

        else:
            self.status_label.setText('<span style="color: rgb(250, 55, 55);">Данные не могут быть пустыми!</span>')


    def expand_button_clicked(self):
        screen = QDesktopWidget().screenGeometry()
        width, height = screen.width(), screen.height()

        self.resize(width, height)


    def stop_point_button_clicked(self):
        selected_item = self.time_box.currentText()
        company = self.company_box.currentText()
    
        if selected_item == 'час пик':
            time = '05-10'
        elif selected_item == 'вечерчние часы пик':
            time = '17-21'
        else:
            time = '03-24'
            
        selected_date = self.date_edit.dateTime().date()
        self.date = selected_date.toString("yyyy-MM-dd")
        
        if company is None:
            self.status_label.setText('<span style="color: rgb(250, 55, 55);">Выберите перевозчика!</span>')
            return

        if self.path == '':
            self.status_label.setText('<span style="color: rgb(250, 55, 55);">Не введен путь к маршрутам!</span>')
            return
            
        self.status_label.setText('Получаем варианты из РНИС...')
        self.network = AsyncNetworkVariants(self, self.path, self.date, time, company, self.flag)
        asyncio.run(self.network.progress_bar(type=3))
        self.progress.setValue(100)


    def create_buffers(self, layer, buffer_distance):
        '''Создание буфферного слоя'''
        buffer_params = {
            'INPUT': layer,
            'DISTANCE': buffer_distance,
            'SEGMENTS': 10,
            'DISSOLVE': False,
            'OUTPUT': 'memory:'
        }
        buffer_result = processing.run("native:buffer", buffer_params, feedback=QgsProcessingFeedback())
        return buffer_result['OUTPUT']
    

    def get_original_point_by_id(self, feature_index, layer):
        '''Получение точки остановки по ее номеру.'''
        features = list(layer.getFeatures())
        if feature_index < len(features):
            return features[feature_index].geometry().asPoint()
        return None
    

    def get_data_layer_by_id(self, ids, layers):
        route_numbers = [ids['1route_peregon_num'], ids['2route_peregon_num']]
        zagr = 0
        passp = 0

        for index, layer in enumerate(layers):
            layer_name = layer.name()
            vectors = QgsProject.instance().mapLayersByName(layer_name)
            vectors = [vector for vector in vectors if vector.geometryType() == QgsWkbTypes.LineGeometry]
            if len(vectors) == 1:
                features = list(vectors[0].getFeatures())[route_numbers[index]].attributes()
                if features[1] != 'None' and features[6] != 'None':
                    zagr += int(features[1])
                    passp += int(features[6])
        return {
            'sum_zagr': zagr,
            'sum_passp': passp,
            'num1': route_numbers[0],
            'num2': route_numbers[1],
        }
    

    def get_default_data_json(self):
        data = {
            "start": None,
            "stop": None,
            "points": None
        }
        return data
    
    
    def get_default_feature(self):
        return {
            'type': 'Feature',
            'properties': {
                'Перегон первого маршрута': None,
                'Перегон второго маршрута': None,
                'Первый маршрут': None,
                'Второй маршрут': None,
                'Суммарная загруженность': None,
                'Суммарный пасажиропоток': None
            },
            'geometry': {
                'type': 'LineString',
                'coordinates': None
            }
        }


    def create_geo_json(self, line_points, features, layers):
        default_geojson = {
            'type': 'FeatureCollection',
            'features': []
        }

        for index, data in enumerate(features):
            coordinates = []
            coordinates.append([
                line_points[index].x(),
                line_points[index].y()
            ])
            if index + 1 < len(line_points):
                coordinates.append([
                    line_points[index + 1].x(),
                    line_points[index + 1].y()
                ])
            feature = self.get_default_feature()
            feature['properties']['Перегон первого маршрута'] = data['peregon1']
            feature['properties']['Перегон второго маршрута'] = data['peregon2']
            feature['properties']['Первый маршрут'] = layers[0].name()
            feature['properties']['Второй маршрут'] = layers[1].name()
            feature['properties']['Суммарная загруженность'] = data['sum_zagr']
            feature['properties']['Суммарный пасажиропоток'] = data['sum_passp']
            feature['geometry']['coordinates'] = coordinates
            default_geojson['features'].append(feature)

        for point in line_points:
            default_geojson['features'].append({
                'type': 'Feature',
                'properties': {},
                'geometry': {
                    'type': 'Point',
                    'coordinates': [
                        point.x(),
                        point.y()
                    ]
                }
            })
        
        return default_geojson
    

    def button_intersection_clicked(self):
        layers = []
        active_layers = self.get_visible_layers(QgsProject.instance().layerTreeRoot())
        active_layers = [item for item in active_layers if item.name() != "2gis Map"]
        coordinates_by_layers = []
        for layer in active_layers:
            if layer.geometryType() == QgsWkbTypes.PointGeometry:
                    layers.append(layer)
                    if layer.featureCount() > 0:
                        features = layer.getFeatures()
                        points = []
                        for feature in features:
                            geometry_type = feature.geometry().wkbType()
                            if geometry_type == QgsWkbTypes.LineString:
                                points.extend(feature.geometry().asPolyline())

                        if len(points) != 0:
                            coordinates_by_layers.append({"layer_name": layer.name(), "geometry": points})
        

        layer1 = layers[0]
        layer2 = layers[1]

        buffer_distance = 0.001
        buffer_layer1 = self.create_buffers(layer1, buffer_distance)
        buffer_layer2 = self.create_buffers(layer2, buffer_distance)
        result = []
        flag = False
        start_point = None
        end_point = None
        points = []
        peregons = []
        for feature1_index, feature1 in enumerate(buffer_layer1.getFeatures()):
            geom1 = feature1.geometry()
            original_point1 = self.get_original_point_by_id(feature1_index, layer1)
            
            for feature2_index, feature2 in  enumerate(buffer_layer2.getFeatures()):
                geom2 = feature2.geometry()
                if geom1.intersects(geom2):
                    flag = True
                    if start_point is not None:
                        if end_point is not None:
                            points.append(end_point)
                        end_point = original_point1

                        peregons.append({
                            "1route_peregon_num": feature1_index,
                            "2route_peregon_num": feature2_index
                        })
                    else:
                        start_point = original_point1
                    break

            if not flag or (feature1_index == len(list(buffer_layer1.getFeatures())) - 2 and flag):
                default_json = self.get_default_data_json()
                default_json['start'] = {'x': start_point.x(), 'y': start_point.y()} if start_point else None
                default_json['stop'] = {'x': end_point.x(), 'y': end_point.y()} if end_point else None
                default_json['points'] = [{'x': p.x(), 'y': p.y()} for p in points]
                result.append(default_json)
                start_point = None
                end_point = None
                points = []
            flag = False

        line_points = []

        for item in result:
            start = item['start']
            stop = item['stop']
            points = item['points']
            if points and len(points) >  2:
                if start:
                    line_points.append(QgsPointXY(start['x'], start['y']))
                for point in points:
                    line_points.append(QgsPointXY(point['x'], point['y']))
                if stop:
                    line_points.append(QgsPointXY(stop['x'], stop['y']))
        
        feature_data = []

        for index, point  in enumerate(line_points):
            if index < len(peregons):
                route_peregons = peregons[index]
                attibutes_info = self.get_data_layer_by_id(route_peregons, layers)
                data = {
                    'point': point,
                    'sum_zagr': attibutes_info['sum_zagr'],
                    'sum_passp': attibutes_info['sum_passp'],
                    'peregon1': attibutes_info['num1'],
                    'peregon2': attibutes_info['num2'],
                }
                feature_data.append(data)

        geojson = self.create_geo_json(line_points, feature_data, layers)
        geojson_obj = json.dumps(geojson)
        new_layer_line = QgsVectorLayer(geojson_obj + "|geometrytype=LineString", 'Пересечение', "ogr")
        
        QgsProject.instance().addMapLayer(new_layer_line)
    

    def jk_layer_button_clicked(self):
        json_file = 'C:\\Users\\DoroninIA\\Desktop\\QGIS\\QGIS-Plugin-MTDI-master\\route_network\\jsonData\\JK.geojson'
        qml_file = 'C:\\Users\\DoroninIA\\Desktop\\QGIS\\QGIS-Plugin-MTDI-master\\route_network\\jsonData\\jk.qml'
        group_name = 'Слой ЖК'

        self.insert_file_layer_to_map(json_file, qml_file, group_name, 'ЖК')
        

    def jd_layer_button_clicked(self):
        files = [
            ('C:\\Users\\DoroninIA\\Desktop\\QGIS\\QGIS-Plugin-MTDI-master\\route_network\\jsonData\\d1.geojson',
             'C:\\Users\\DoroninIA\\Desktop\\QGIS\\QGIS-Plugin-MTDI-master\\route_network\\jsonData\\d1.qml'),

            ('C:\\Users\\DoroninIA\\Desktop\\QGIS\\QGIS-Plugin-MTDI-master\\route_network\\jsonData\\d2.geojson',
             'C:\\Users\\DoroninIA\\Desktop\\QGIS\\QGIS-Plugin-MTDI-master\\route_network\\jsonData\\d2.qml'),

            ('C:\\Users\\DoroninIA\\Desktop\\QGIS\\QGIS-Plugin-MTDI-master\\route_network\\jsonData\\d3.geojson',
             'C:\\Users\\DoroninIA\\Desktop\\QGIS\\QGIS-Plugin-MTDI-master\\route_network\\jsonData\\d3.qml'),

            ('C:\\Users\\DoroninIA\\Desktop\\QGIS\\QGIS-Plugin-MTDI-master\\route_network\\jsonData\\d4.geojson',
             'C:\\Users\\DoroninIA\\Desktop\\QGIS\\QGIS-Plugin-MTDI-master\\route_network\\jsonData\\d4.qml')
        ]
        
        group_name = 'Cлой ЖД'
        index = 1
        for file, style in files:
            self.insert_file_layer_to_map(file, style, group_name, f'Д-{index}')
            index += 1


    def population_layer_button_clicked(self):
        json_file = 'C:\\Users\\DoroninIA\\Desktop\\QGIS\\QGIS-Plugin-MTDI-master\\route_network\\jsonData\\population.json'
        qml_file = 'C:\\Users\\DoroninIA\\Desktop\\QGIS\\QGIS-Plugin-MTDI-master\\route_network\\jsonData\\population.qml'
        group_name = 'Слой плотности населения'
        self.insert_file_layer_to_map(json_file, qml_file, group_name, 'Плотность населения')


    def insert_file_layer_to_map(self, json_file, qml_file, group_name, layer_name):
        layer = QgsVectorLayer(json_file, layer_name, 'ogr')
        layer.loadNamedStyle(qml_file)
   
        root = QgsProject.instance().layerTreeRoot()
        group = next(
            (child for child in root.children() if isinstance(child, QgsLayerTreeGroup) and child.name() == group_name),
            None)
        
        if group is None:
            group = root.addGroup(group_name)

        QgsProject.instance().addMapLayer(layer, False)
        group.insertChildNode(0, QgsLayerTreeLayer(layer))

