# -*- coding: utf-8 -*-
"""
/***************************************************************************
 RouteNetworkDialog
                                 A QGIS plugin
 Route Network for MTDI
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2024-03-28
        git sha              : $Format:%H$
        copyright            : (C) 2024 by Doronin Ivan
        email                : ivandoronin22@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
import asyncio
import pandas as pd
import time
import json
from qgis.PyQt import uic
from qgis.PyQt import QtWidgets
from qgis.core import *
from qgis.gui import QgsMapCanvas
from qgis.PyQt.QtGui import *
from PyQt5.QtCore import *
from PyQt5.QtWidgets import *
from shapely.geometry import box
import processing
from .asyncNetworkVariants import AsyncNetworkVariants

# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'route_network_dialog_base.ui'))


class RouteNetworkDialog(QtWidgets.QDialog, FORM_CLASS):


    def __init__(self, parent=None):
        """Constructor."""
        super(RouteNetworkDialog, self).__init__(parent)
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)

        # Variables.
        self.path = ''
        self.date_from = ''
        self.date_to = ''
        self.reg = ''
        self.df = None
        
        # Check boxes.
        self.company_box.addItem("Выберите перевозчика...", None)
        self.company_box.addItem("МТА", 1)
        self.company_box.addItem("КП", 2)

        self.time_box.addItem("Выберите время...", None)
        self.time_box.addItem("весь день", 1)
        self.time_box.addItem("час пик", 2)
        self.time_box.addItem("вечерчние часы пик", 3)
        self.time_box.hide()

        self.check_box.stateChanged.connect(self.handleCheckBoxStateChanged)
        self.check_box_period.stateChanged.connect(self.periodCheckBoxStateChanged)

        self.check_box_period.hide()
        self.period_label.hide()
        self.label_date_from.hide()
        self.label_date_to.hide()
        self.date_from_edit.hide()
        self.date_to_edit.hide()
        self.excel_export_info_button.hide()
        self.table_widget_info.hide()
        self.table_widget.hide() 

        # Buttons.
        self.button_prc.clicked.connect(self.button_percentage_clicked)
        self.button_dwnl.clicked.connect(self.button_download_clicked)
        self.button_prc_group.clicked.connect(self.button_percentage_group_clicked)
        self.button_find.clicked.connect(self.button_find_clicked)
        self.button_layer.clicked.connect(self.button_layer_clicked)
        self.save_button.clicked.connect(self.save_button_clicked)
        self.save_button.setVisible(False)
        self.excel_export_info_button.clicked.connect(self.save_button_clicked)
        self.stop_point_button.clicked.connect(self.stop_point_button_clicked)
        self.intersection_button.clicked.connect(self.button_intersection_clicked)
        self.jk_layer_button.clicked.connect(self.jk_layer_button_clicked)
        self.jd_layer_button.clicked.connect(self.jd_layer_button_clicked)
        self.population_layer_button.clicked.connect(self.population_layer_button_clicked)

        # Date.
        self.date_from_edit.setDate(QDate.currentDate())
        self.date_to_edit.setDate(QDate.currentDate())

        # Table Widgets.
        self.table_widget.cellClicked.connect(self.cell_clicked)


    def get_visible_layers(self, node):
        layers = []
        for child_node in node.children():
            if isinstance(child_node, QgsProject) or child_node.isVisible():
                if isinstance(child_node, QgsProject):
                    # Recursively get layers from child groups
                    layers.extend(get_visible_layers(child_node))
                elif isinstance(child_node, QgsLayerTreeGroup):
                    # Recursively get layers from child groups
                    layers.extend(self.get_visible_layers(child_node))
                else:
                    # For QgsLayerTreeLayer objects, add the layer to the list
                    layers.append(child_node.layer())
        return layers


    def get_active_layers(self):
        # Получить список всех активно выбранных слоев в Layers Panel
        selected_layers = self.get_visible_layers(QgsProject.instance().layerTreeRoot())
        layer_coordinates_by_peregons = []
        for layer in selected_layers:
            if isinstance(layer, QgsVectorLayer):
                if layer.featureCount() > 0:
                    coordinates = self.get_coordinates_by_peregons(layer)
                    if len(coordinates) != 0:
                        if 'reverse' in layer.name():
                            coordinates = list(reversed(coordinates))

                        layer_coordinates_by_peregons.append({
                            'name': layer.name(),
                            'coordinates': coordinates
                        })

        return layer_coordinates_by_peregons


    def get_coordinates_by_peregons(self, layer):
        coordinates_list = []
        start_peregon = None
        end_peregon = None
        for feature in layer.getFeatures():
            geometry_type = feature.geometry().wkbType()
            if geometry_type == QgsWkbTypes.Point:
                point = feature.geometry().asPoint()
                if start_peregon is not None:
                    end_peregon = (point.x(), point.y())
                    coordinates_list.append({'start_peregon': start_peregon, 'end_peregon': end_peregon})
                    start_peregon = end_peregon
                if start_peregon is None:
                    start_peregon = (point.x(), point.y())

        return coordinates_list
  
  
    def get_active_layers_in_group(self, group):
        active_layers = []
        for layer_tree_node in group.children():
            if layer_tree_node.isVisible():
                layer = layer_tree_node.layer()
                if isinstance(layer, QgsVectorLayer):
                    if layer.featureCount() > 0:
                        coordinates = self.get_coordinates_by_peregons(layer)
                        if len(coordinates) != 0:
                            if 'обратное' in layer.name():
                                coordinates = list(reversed(coordinates))

                            active_layers.append({
                                'name': layer.name(),
                                'coordinates': coordinates
                            })
        return active_layers

        
    def get_visible_group_layers(self):
        root = QgsProject.instance().layerTreeRoot()
        group_layers_dict = []
        for child in root.children():
            if isinstance(child, QgsLayerTreeGroup):
                active_layers = self.get_active_layers_in_group(child)
                if len(active_layers) != 0:
                    group_layers_dict.append({'group_name': child.name(), 'layers': active_layers})
        # print(group_layers_dict)
        if len(group_layers_dict) != 2:
            return None
        
        return group_layers_dict
    
    
    def find_coordinate_peregon(self, peregons_coordinates, second_layer):
        distance_area = QgsDistanceArea()
        distance_area.setEllipsoid('WGS84')
        flag = False
        for peregon in second_layer:
            if flag == False:
                point_start_1 = QgsPointXY(peregons_coordinates['start_peregon'][1], peregons_coordinates['start_peregon'][0])
                point_start_2 = QgsPointXY(peregon['start_peregon'][1], peregon['start_peregon'][0])
                distance_x = distance_area.measureLine([point_start_1, point_start_2])
                
            point_end_1 = QgsPointXY(peregons_coordinates['end_peregon'][1], peregons_coordinates['end_peregon'][0])
            point_end_2 = QgsPointXY(peregon['end_peregon'][1], peregon['end_peregon'][0])
            distance_y = distance_area.measureLine([point_end_1, point_end_2])
            if (distance_x <= 200) and (distance_y <= 200):
                return 1
            elif (distance_x <= 200) and (distance_y > 200):
                flag = True
        return 0


    def show_table(self, height, width, layer_coordinates_by_peregons):
        column_headers = []
        row_headers = []
        values = []
        self.analysis_progress.setMaximum(len(layer_coordinates_by_peregons))
        index = 0
        self.analysis_status_label.setText('Расчет вариантов...')
        for item in layer_coordinates_by_peregons:
            index += 1
            name_1 = item['name']
            rows = []
            for item2 in layer_coordinates_by_peregons:
                matching_coordinates = 0
                for coordinate in item['coordinates']:
                    matching_coordinates += self.find_coordinate_peregon(coordinate, item2['coordinates'])
                peregons = f"{matching_coordinates}/{len(item['coordinates'])}"
                percent = (matching_coordinates / len(item['coordinates'])) * 100

                name_2 = item2['name']
                rows.append(f'совпадает на {round(percent, 2)} % ({peregons} перегонов)')
                if len(column_headers) < width:
                    column_headers.append(name_2)
            values.append(rows)
            if len(row_headers) < height:
                row_headers.append(name_1)
            time.sleep(0.1)
            self.analysis_progress.setValue(index)
            QApplication.processEvents()
            
        self.table_widget.show()
        self.table_widget.setRowCount(height)
        self.table_widget.setColumnCount(width)
        self.table_widget.setHorizontalHeaderLabels(column_headers)
        self.table_widget.setVerticalHeaderLabels(row_headers)
        
        for row in range(len(values)):
            for col in range(len(values[0])):
                self.table_widget.setColumnWidth(col, 200)
                item = QTableWidgetItem(values[row][col])
                percent = float(values[row][col].split(' ')[2])
                if percent >= 50.0 and percent < 70.0 and row != col:
                    item.setBackground(QColor(200, 255, 200))
                if percent >= 70.0 and percent < 80.0 and row != col:
                    item.setBackground(QColor(255, 255, 200))
                if percent >= 80.0 and row != col:
                    item.setBackground(QColor(255, 200, 200))
                if row == col:
                    item = QTableWidgetItem()
                    item.setBackground(QColor(240, 240, 240))
                if percent == 0.0:
                    item = QTableWidgetItem()
                self.table_widget.setItem(row, col, item)
        self.analysis_status_label.setText('Готов к работе')

        dataset = {
            'Вариант_1': [],
            'Вариант_2': [],
            'Дублированность': [],
            'Совпадение_перегонов': []
            }

        for row in range(self.table_widget.rowCount()):
            row_data = []
            row_data.append(row_headers[row])
            for column in range(self.table_widget.columnCount()):
                item = self.table_widget.item(row, column)
                if item is not None:
                    row_data.append(item.text())
                    if item.text() != '':
                        row_text = self.table_widget.horizontalHeaderItem(row).text()
                        column_text = self.table_widget.verticalHeaderItem(column).text()
                        dubl = item.text().split(' ')[2] + ' %'
                        count_peregons = item.text().split(' ')[4].replace('(', '').replace(')', '').split(' ')[0]

                        dataset['Вариант_1'].append(row_text)
                        dataset['Вариант_2'].append(column_text)
                        dataset['Дублированность'].append(dubl)
                        dataset['Совпадение_перегонов'].append(count_peregons)
                else:
                    row_data.append('')
        col_data = ['#']
        col_data.extend(column_headers)
        df = pd.DataFrame(
            dataset
        )
        return df


    def show_table_for_group(self, width, height, group_layers):
        group_1 = group_layers[0]
        group_2 = group_layers[1]
        column_headers = []
        row_headers = []
        values = []
        index = 0

        self.analysis_progress.setValue(0)
        self.analysis_progress.setMaximum(len(group_layers))
        self.analysis_status_label.setText('Расчет вариантов...')
        
        for layer in group_1['layers']:
            layer_name_1 = layer['name']
            layer_coordinates_1 = layer['coordinates']
            rows = []
            for layer_2 in group_2['layers']:
                layer_name_2 = layer_2['name']
                matching_coordinates = 0
                for coordinate in layer_coordinates_1:
                    matching_coordinates += self.find_coordinate_peregon(coordinate, layer_2['coordinates'])
                peregons = f"{matching_coordinates} / {len(layer_coordinates_1)}"
                percent = (matching_coordinates / len(layer_coordinates_1)) * 100
                rows.append(f'совпадает на {round(percent, 2)} % ({peregons} перегонов)')
                if len(column_headers) < width:
                    column_headers.append(layer_name_2)
                    
            values.append(rows)
            if len(row_headers) < height:
                row_headers.append(layer_name_1)
                
            time.sleep(0.1)
            self.analysis_progress.setValue(index)
            QApplication.processEvents()
            
        self.table_widget.show()
        self.table_widget.setRowCount(height)
        self.table_widget.setColumnCount(width)
        self.table_widget.setHorizontalHeaderLabels(column_headers)
        self.table_widget.setVerticalHeaderLabels(row_headers)

        for row in range(len(values)):
            for col in range(len(values[0])):
                self.table_widget.setColumnWidth(col, 200)
                item = QTableWidgetItem(values[row][col])
                percent = float(values[row][col].split(' ')[2])
                if percent >= 50.0 and percent < 70.0 and row != col:
                    item.setBackground(QColor(200, 255, 200))
                if percent >= 70.0 and percent < 80.0 and row != col:
                    item.setBackground(QColor(255, 255, 200))
                if percent >= 80.0 and row != col:
                    item.setBackground(QColor(255, 200, 200))
                if percent == 0.0:
                    item = QTableWidgetItem()
                self.table_widget.setItem(row, col, item)
        self.analysis_status_label.setText('Подготавливаю данные')

        dataset = {
            'Вариант_1': [],
            'Вариант_2': [],
            'Дублированность': [],
            'Совпадение_перегонов': []
            }
        
        for row in range(self.table_widget.rowCount()):
            row_data = []
            row_data.append(row_headers[row])
            for column in range(self.table_widget.columnCount()):
                item = self.table_widget.item(row, column)
                if item is not None:
                    row_data.append(item.text())
                    if item.text() != '':
                        row_obj = self.table_widget.horizontalHeaderItem(row)
                        row_text = '' if row_obj is None else row_obj.text()
                        column_text = self.table_widget.verticalHeaderItem(column).text()
                        dubl = item.text().split(' ')[2] + ' %'
                        count_peregons = item.text().split(' ')[4].replace('(', '').replace(')', '').split(' ')[0]

                        dataset['Вариант_1'].append(row_text)
                        dataset['Вариант_2'].append(column_text)
                        dataset['Дублированность'].append(dubl)
                        dataset['Совпадение_перегонов'].append(count_peregons)
                else:
                    row_data.append('')
        self.analysis_status_label.setText('Готов к работе')
        col_data = ['#']
        col_data.extend(column_headers)

        df = pd.DataFrame(
            dataset
        )
        return df
    

    def set_layer_visibility(self, layer, visibility):
        root = QgsProject.instance().layerTreeRoot()

        # Iterate through layer tree to find the layer
        for child in root.children():
            if isinstance(child, QgsLayerTreeGroup):
                # Check if the child is a group
                for group_child in child.children():
                    if group_child.layer() == layer:
                        group_child.setItemVisibilityChecked(visibility)
                        break
            elif child.layer() == layer:
                child.setItemVisibilityChecked(visibility)
                break


    def set_active_layers(self, target_layers):
        layers = QgsProject.instance().mapLayers().values()

        for layer in layers:
            is_target_layer = any(keyword in layer.name() for keyword in target_layers)
            if layer.name() != '2gis Map' and layer.name() != 'OSM Standard' :
                self.set_layer_visibility(layer, is_target_layer)
    

    def button_percentage_clicked(self):
        self.analysis_status_label.setText('Подготавливаем варианты...')
        active_coordinates = self.get_active_layers()
        height = len(active_coordinates)
        width = len(active_coordinates)
        self.df = self.show_table(height, width, active_coordinates)
        self.save_button.setVisible(True)
        

    def button_percentage_group_clicked(self):
        self.analysis_status_label.setText('Подготавливаем варианты...')
        goup_layer_coordinates = self.get_visible_group_layers()
        if goup_layer_coordinates is not None:
            height = len(goup_layer_coordinates[0]['layers'])
            width = len(goup_layer_coordinates[1]['layers'])
            self.df = self.show_table_for_group(width, height, goup_layer_coordinates)
            self.save_button.setVisible(True)
        else:
            self.analysis_status_label.setText('<span style="color: rgb(250, 55, 55);">Выберите две группы слоев!</span>')


    def button_find_clicked(self):
        reg = str(self.lineEdit.text()).replace(' ', '')
        if reg != "" and reg.isdigit():
            filtered_layers = [layer for layer in QgsProject.instance().mapLayers().values()
                    if reg == layer.name().split('-')[len(layer.name().split('-')) - 2]]

            self.set_active_layers([layer.name() for layer in filtered_layers])
            self.lineEdit.setText('')
        else:
            self.status_general_label.setText('<span style="color: rgb(250, 55, 55);">Поле не может быть пустым!</span>')
        return
  

    def button_download_clicked(self):
        self.progress.setValue(0)
        self.status_general_label.setText('Готов к работе')
        selected_item = self.time_box.currentText()
        company = self.company_box.currentText()
    
        if selected_item == 'час пик':
            time = '05-10'
        elif selected_item == 'вечерчние часы пик':
            time = '17-21'
        else:
            time = '03-24'
            
        selected_date_from = self.date_from_edit.dateTime().date()
        selected_date_to = self.date_to_edit.dateTime().date()

        self.date_from = selected_date_from.toString("yyyy-MM-dd")
        self.date_to = selected_date_to.toString('yyyy-MM-dd') if self.check_box_period.isChecked() else None

        self.period = [self.date_from + 'T00:00:00+03:00', self.date_to + 'T00:00:00+03:00' if self.date_to is not None else self.date_from + 'T00:00:00+03:00']

        if company == 'Выберите перевозчика...':
            self.status_general_label.setText('<span style="color: rgb(250, 55, 55);">Выберите перевозчика!</span>')
            return

        array_regs = self.get_array_regs()
        if array_regs == None or len(array_regs) < 1:
            self.status_general_label.setText('<span style="color: rgb(250, 55, 55);">Введите рег. номера!</span>')
            return

        self.status_general_label.setText('Получаем варианты из РНИС...')
        self.network = AsyncNetworkVariants(self, array_regs, time, company, self.check_box.isChecked(), date_from=self.date_from, date_to=self.date_to, period=self.period)
        asyncio.run(self.network.progress_bar())
        self.progress.setValue(100)
        

    def button_layer_clicked(self):
        self.progress.setValue(0)
        self.status_general_label.setText('Готов к работе')
        selected_item = self.time_box.currentText()
        company = self.company_box.currentText()
    
        if selected_item == 'час пик':
            time = '05-10'
        elif selected_item == 'вечерчние часы пик':
            time = '17-21'
        else:
            time = '03-24'
        
        selected_date_from = self.date_from_edit.dateTime().date()
        selected_date_to = self.date_to_edit.dateTime().date()

        self.date_from = selected_date_from.toString("yyyy-MM-dd")
        self.date_to = selected_date_to.toString('yyyy-MM-dd') if self.check_box_period.isChecked() else None

        self.period = [self.date_from + 'T00:00:00+03:00', self.date_to + 'T00:00:00+03:00' if self.date_to is not None else self.date_from + 'T00:00:00+03:00']
        
        if company == 'Выберите перевозчика...':
            self.status_general_label.setText('<span style="color: rgb(250, 55, 55);">Выберите перевозчика!</span>')
            return

        array_regs = self.get_array_regs()
        if array_regs == None or len(array_regs) < 1:
            self.status_general_label.setText('<span style="color: rgb(250, 55, 55);">Введите рег. номера!</span>')
            return

        self.status_general_label.setText('Получаем варианты из РНИС...')
        self.network = AsyncNetworkVariants(self, array_regs, time, company, self.check_box.isChecked(), date_from=self.date_from, date_to=self.date_to, period=self.period)
        asyncio.run(self.network.progress_bar(type=2))
        self.progress.setValue(100)


    def get_array_regs(self):
        return[int(item) for item in str(self.reg_text_edit.toPlainText()).split(',') if item.replace(' ', '').isdigit()]


    def cell_clicked(self, row, column):
        filtered_layers = []
        for layer in QgsProject.instance().mapLayers().values():
            if (layer.name() == self.table_widget.verticalHeaderItem(row).text()) or (layer.name() == self.table_widget.horizontalHeaderItem(column).text()) or (layer.name() == '2gis Map'):
                if layer.name() not in filtered_layers:
                    filtered_layers.append(layer.name())

        self.set_active_layers(filtered_layers)


    def handleCheckBoxStateChanged(self, state):
        if state == Qt.Checked:
            self.time_box.show()
            self.period_label.show()
            self.check_box_period.show()
            self.label_date_from.show()
            self.label_date_to.hide()
            self.date_from_edit.show()
            self.date_to_edit.hide()
        else:
            if self.check_box_period.isChecked():
                self.check_box_period.setChecked(False)
            self.check_box_period.hide()
            self.period_label.hide()
            self.label_date_from.hide()
            self.label_date_to.hide()
            self.date_from_edit.hide()
            self.date_to_edit.hide()
            self.time_box.hide()


    def periodCheckBoxStateChanged(self, state):
        if state == Qt.Checked:
            self.label_date_to.show()
            self.date_to_edit.show()
        else:
            self.label_date_to.hide()
            self.date_to_edit.hide()


    def save_button_clicked(self):
        if self.df is not None:
            options = QFileDialog.Options()
            options |= QFileDialog.DontUseNativeDialog
            file_name, _ = QFileDialog.getSaveFileName(self, "Выберите директорию", "", "Excel Files (*.xlsx);;All Files (*)", options=options)
            
            if file_name:
                self.df.to_excel(file_name + '.xlsx', index=False)

        else:
            self.status_general_label.setText('<span style="color: rgb(250, 55, 55);">Данные не могут быть пустыми!</span>')


    def stop_point_button_clicked(self):
        self.progress.setValue(0)
        self.status_general_label.setText('Готов к работе')
        selected_item = self.time_box.currentText()
        company = self.company_box.currentText()
    
        if selected_item == 'час пик':
            time = '05-10'
        elif selected_item == 'вечерчние часы пик':
            time = '17-21'
        else:
            time = '03-24'
            
        selected_date_from = self.date_from_edit.dateTime().date()
        selected_date_to = self.date_to_edit.dateTime().date()

        self.date_from = selected_date_from.toString("yyyy-MM-dd")
        self.date_to = selected_date_to.toString('yyyy-MM-dd') if self.check_box_period.isChecked() else None
        self.period = [self.date_from + 'T00:00:00+03:00', self.date_to + 'T00:00:00+03:00' if self.date_to is not None else self.date_from + 'T00:00:00+03:00']
        
        if not self.check_box.isChecked():
            self.status_general_label.setText('<span style="color: rgb(250, 55, 55);">Выберите дату!</span>')
            return
        
        if company == 'Выберите перевозчика...':
            self.status_general_label.setText('<span style="color: rgb(250, 55, 55);">Выберите перевозчика!</span>')
            return

        array_regs = self.get_array_regs()
        if array_regs == None or len(array_regs) < 1:
            self.status_general_label.setText('<span style="color: rgb(250, 55, 55);">Введите рег. номера!</span>')
            return
            
        self.status_general_label.setText('Получаем варианты из РНИС...')
        self.network = AsyncNetworkVariants(self, array_regs, time, company, self.check_box.isChecked(), date_from=self.date_from, date_to=self.date_to, period=self.period)
        asyncio.run(self.network.progress_bar(type=3))
        self.progress.setValue(100)


    def create_buffers(self, layer, buffer_distance):
        '''Создание буфферного слоя'''
        buffer_params = {
            'INPUT': layer,
            'DISTANCE': buffer_distance,
            'SEGMENTS': 10,
            'DISSOLVE': False,
            'OUTPUT': 'memory:'
        }
        buffer_result = processing.run("native:buffer", buffer_params, feedback=QgsProcessingFeedback())
        return buffer_result['OUTPUT']
    

    def get_original_point_by_id(self, feature_index, layer):
        '''Получение точки остановки по ее номеру.'''
        features = list(layer.getFeatures())
        if feature_index < len(features):
            return features[feature_index].geometry().asPoint()
        return None
    

    def get_data_layer_by_id(self, ids, layers):
        route_numbers = [ids['1route_peregon_num'], ids['2route_peregon_num']]
        zagr = 0
        passp = 0
        total_soc = 0
        total_kom = 0

        for index, layer in enumerate(layers):
            layer_name = layer.name()
            vectors = QgsProject.instance().mapLayersByName(layer_name)
            vectors = [vector for vector in vectors if vector.geometryType() == QgsWkbTypes.LineGeometry]
            if len(vectors) == 1:
                features = list(vectors[0].getFeatures())[route_numbers[index]].attributes()
                if features[1] != 'None' and features[6] != 'None':
                    passp += int(features[11])
                    total_soc += int(features[13])
                    total_kom += int(features[14])
        return {
            'sum_soc': total_soc,
            'sum_kom': total_kom,
            'sum_passp': passp,
            'num1': route_numbers[0],
            'num2': route_numbers[1],
        }
    

    def get_default_data_json(self):
        data = {
            "start": None,
            "stop": None,
            "points": None
        }
        return data
    
    
    def get_default_feature(self):
        return {
            'type': 'Feature',
            'properties': {},
            'geometry': {
                'type': 'LineString',
                'coordinates': None
            }
        }


    def create_geo_json(self, line_points, features, layers):
        default_geojson = {
            'type': 'FeatureCollection',
            'features': []
        }

        for index, data in enumerate(features):
            coordinates = []
            coordinates.append([
                line_points[index].x(),
                line_points[index].y()
            ])
            if index + 1 < len(line_points):
                coordinates.append([
                    line_points[index + 1].x(),
                    line_points[index + 1].y()
                ])
            feature = self.get_default_feature()
            feature['properties']['Перегон первого маршрута'] = str(data['peregon1'])
            feature['properties']['Перегон второго маршрута'] = str(data['peregon2'])
            feature['properties']['Первый маршрут'] = layers[0].name()
            feature['properties']['Второй маршрут'] = layers[1].name()
            feature['properties']['Суммарный пасажиропоток'] = str(data['sum_passp'])
            feature['properties']['Сумма СОЦ'] = str(data['sum_soc'])
            feature['properties']['Сумма КОМ'] = str(data['sum_kom'])
            feature['geometry']['coordinates'] = coordinates
            default_geojson['features'].append(feature)

        for point in line_points:
            default_geojson['features'].append({
                'type': 'Feature',
                'properties': {},
                'geometry': {
                    'type': 'Point',
                    'coordinates': [
                        point.x(),
                        point.y()
                    ]
                }
            })
        
        return default_geojson
    

    def button_intersection_clicked(self):
        layers = []
        active_layers = self.get_visible_layers(QgsProject.instance().layerTreeRoot())
        active_layers = [item for item in active_layers if item.name() != "2gis Map"]
        coordinates_by_layers = []
        for layer in active_layers:
            if layer.geometryType() == QgsWkbTypes.PointGeometry:
                    layers.append(layer)
                    if layer.featureCount() > 0:
                        features = layer.getFeatures()
                        points = []
                        for feature in features:
                            geometry_type = feature.geometry().wkbType()
                            if geometry_type == QgsWkbTypes.LineString:
                                points.extend(feature.geometry().asPolyline())

                        if len(points) != 0:
                            coordinates_by_layers.append({"layer_name": layer.name(), "geometry": points})     

        layer1 = layers[0]
        layer2 = layers[1]

        buffer_distance = 0.001
        buffer_layer1 = self.create_buffers(layer1, buffer_distance)
        buffer_layer2 = self.create_buffers(layer2, buffer_distance)
        result = []
        flag = False
        start_point = None
        end_point = None
        points = []
        peregons = []
        for feature1_index, feature1 in enumerate(buffer_layer1.getFeatures()):
            geom1 = feature1.geometry()
            original_point1 = self.get_original_point_by_id(feature1_index, layer1)
            
            for feature2_index, feature2 in  enumerate(buffer_layer2.getFeatures()):
                geom2 = feature2.geometry()
                if geom1.intersects(geom2):
                    flag = True
                    if start_point is not None:
                        if end_point is not None:
                            points.append(end_point)
                        end_point = original_point1

                        peregons.append({
                            "1route_peregon_num": feature1_index,
                            "2route_peregon_num": feature2_index
                        })
                    else:
                        start_point = original_point1
                    break

            if not flag or (feature1_index == len(list(buffer_layer1.getFeatures())) - 2 and flag):
                default_json = self.get_default_data_json()
                default_json['start'] = {'x': start_point.x(), 'y': start_point.y()} if start_point else None
                default_json['stop'] = {'x': end_point.x(), 'y': end_point.y()} if end_point else None
                default_json['points'] = [{'x': p.x(), 'y': p.y()} for p in points]
                result.append(default_json)
                start_point = None
                end_point = None
                points = []
            flag = False

        line_points = []

        for item in result:
            start = item['start']
            stop = item['stop']
            points = item['points']
            if points and len(points) >  2:
                if start:
                    line_points.append(QgsPointXY(start['x'], start['y']))
                for point in points:
                    line_points.append(QgsPointXY(point['x'], point['y']))
                if stop:
                    line_points.append(QgsPointXY(stop['x'], stop['y']))
        
        feature_data = []

        for index, point  in enumerate(line_points):
            if index < len(peregons):
                route_peregons = peregons[index]
                attibutes_info = self.get_data_layer_by_id(route_peregons, layers)
                data = {
                    'point': point,
                    'sum_soc': attibutes_info['sum_soc'],
                    'sum_kom': attibutes_info['sum_kom'],
                    'sum_passp': attibutes_info['sum_passp'],
                    'peregon1': attibutes_info['num1'],
                    'peregon2': attibutes_info['num2'],
                }
                feature_data.append(data)

        geojson = self.create_geo_json(line_points, feature_data, layers)
        geojson_obj = json.dumps(geojson)
        new_layer_line = QgsVectorLayer(geojson_obj + "|geometrytype=LineString", 'Пересечение', "ogr")
        group_name = 'Пересечения маршрутов'

        root = QgsProject.instance().layerTreeRoot()
        group = next(
            (child for child in root.children() if isinstance(child, QgsLayerTreeGroup) and child.name() == group_name),
            None)
        
        if group is None:
            group = root.addGroup(group_name)

        QgsProject.instance().addMapLayer(new_layer_line, False)
        group.insertChildNode(0, QgsLayerTreeLayer(new_layer_line))


    def jk_layer_button_clicked(self):
        base_path = os.path.dirname(os.path.abspath(__file__))

        dataset_path = os.path.join(base_path, 'jsonData')

        data_files = [
            os.path.join(dataset_path, 'JK.geojson'),
            os.path.join(dataset_path, 'jk.qml')
        ]

        json_file = data_files[0]
        qml_file = data_files[1]
        group_name = 'Слой ЖК'

        self.insert_file_layer_to_map(json_file, qml_file, group_name, 'ЖК')
        

    def jd_layer_button_clicked(self):
        base_path = os.path.dirname(os.path.abspath(__file__))

        dataset_path = os.path.join(base_path, 'jsonData')

        data_files_path = [
            os.path.join(dataset_path, 'd1.geojson'),
            os.path.join(dataset_path, 'd1.qml'),
            os.path.join(dataset_path, 'd2.geojson'),
            os.path.join(dataset_path, 'd2.qml'),
            os.path.join(dataset_path, 'd3.geojson'),
            os.path.join(dataset_path, 'd3.qml'),
            os.path.join(dataset_path, 'd4.geojson'),
            os.path.join(dataset_path, 'd4.qml'),
        ]
    
        files = [
            (data_files_path[0], data_files_path[1]),

            (data_files_path[2], data_files_path[3]),

            (data_files_path[4], data_files_path[5]),

            (data_files_path[6], data_files_path[7])
        ]

        dataset_path = os.path.join(base_path, 'jsonData', 'stopsData')
        stop_point_files = [
            os.path.join(dataset_path, 'MCD1-stops.geojson'),
            os.path.join(dataset_path, 'MCD2-stops.geojson'),
            os.path.join(dataset_path, 'MCD3-stops.geojson'),
            os.path.join(dataset_path, 'MCD4-stops.geojson')
        ]

        dataset_path = os.path.join(base_path, 'jsonData', 'datasets')
        data_files = [
            os.path.join(dataset_path, 'MCD1.json'),
            os.path.join(dataset_path, 'MCD2.json'),
            os.path.join(dataset_path, 'MCD3.json'),
            os.path.join(dataset_path, 'MCD4.json')
        ]
        
        group_name = 'Cлой ЖД'
        index = 1
        for file, style in files:
            self.insert_file_layer_to_map(file, style, group_name, f'Д-{index}', data_files[index - 1], stop_point_file_name=stop_point_files[index - 1])
            index += 1


    def population_layer_button_clicked(self):
        base_path = os.path.dirname(os.path.abspath(__file__))
        dataset_path = os.path.join(base_path, 'jsonData')
        json_file = os.path.join(dataset_path, 'population.json')
        qml_file = os.path.join(dataset_path, 'population.qml')
        group_name = 'Слой плотности населения'
        self.insert_file_layer_to_map(json_file, qml_file, group_name, 'Плотность населения')


    def insert_file_layer_to_map(self, json_file, qml_file, group_name, layer_name, dataset_file_name=None, stop_point_file_name=None):
        layer = QgsVectorLayer(json_file, layer_name, 'ogr')
        layer.loadNamedStyle(qml_file)
   
        root = QgsProject.instance().layerTreeRoot()
        group = next(
            (child for child in root.children() if isinstance(child, QgsLayerTreeGroup) and child.name() == group_name),
            None)
        
        if group is None:
            group = root.addGroup(group_name)

        QgsProject.instance().addMapLayer(layer, False)
        group.insertChildNode(0, QgsLayerTreeLayer(layer))

        if stop_point_file_name is not None:
            geojson = self.get_json_file(stop_point_file_name)
            data = self.get_json_file(dataset_file_name)
            geojson = json.dumps(self.configure_jk_point_layer(geojson, data))
            point_layer = QgsVectorLayer(geojson, layer_name + ' станции', 'ogr')

            QgsProject.instance().addMapLayer(point_layer, False)
            group.insertChildNode(0, QgsLayerTreeLayer(point_layer))


    def configure_jk_point_layer(self, geojson, data):
        for feature in geojson['features']:
            name = feature['properties']['name']
            for item in data:
                if name.upper() == item['name'].upper():
                    feature['properties']['Пасспоток'] = str(item['passp'])
                    feature['properties']['Зашло'] = str(item['enter'])
                    feature['properties']['Вышло'] = str(item['exit'])
                    feature['properties']['Льготники'] = str(item['benefits'])
                    feature['properties']['Коммерция'] = str(item['commerce'])
        return geojson


    def create_downloaded_layer_info_table(self, type, data):
        self.excel_export_info_button.show()
        self.table_widget_info.show()
        column_index = 0
        column_headers = []
        if type == 'layer':
            column_headers = ['Кол-во маршрутов', 'Кол-во вариантов', 'Кол-во с пассп.', 'Кол-во без пассп.', 'Общ. пассп.', 'Итог Соц', 'Итог Ком']
        elif type == 'network':
            column_headers = ['Кол-во маршрутов', 'Кол-во вариантов', 'Итог Соц', 'Итог Ком', 'Итог Общ.']
        elif type == 'point':
            column_headers = ['Кол-во маршрутов', 'Кол-во вариантов', 'Пасспоток', 'Кол-во Соц', 'Кол-во Ком']
        else:
            column_headers = ['Кол-во маршрутов', 'Кол-во вариантов']

        self.table_widget_info.setRowCount(1)
        self.table_widget_info.setColumnCount(len(column_headers))
        self.table_widget_info.setHorizontalHeaderLabels(column_headers)

        for value in data:
            self.table_widget_info.setColumnWidth(column_index, 200)
            item = QTableWidgetItem(str(value))
            self.table_widget_info.setItem(0, column_index, item)
            column_index += 1

        dataset = {}
        for i, item in enumerate(column_headers):
            dataset[item] = data[i]

        self.df = pd.DataFrame(
            dataset,
            index=[0]
        )
        self.status_general_label.setText('Готов к работе')

    
    def get_json_file(self, filepath):
        with open(filepath, encoding='utf-8') as f:
            data = json.load(f)
        return data
    